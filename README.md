### თავდაპირველად უნდა ვიყოთ სწორ დირექტორიაში სადაც მთლიანი პროექტი გვაქ..

```bash
cd <directory name>
```

### სერვისის გაშვების და გადამოწმების ბრძანებები:

1. Docker იმიჯების აშენება:
    
    ```bash
    docker-compose build
    ```
    
    - ეს ბრძანება ააშენებს კონფიგურაციის მიხედვით ყველა სერვისის Docker იმიჯებს.
2. კონტეინერების გაშვება detached რეჟიმში:
    
    ```bash
    docker-compose up -d
    ```
    
    ეს ბრძანება გაუშვებს ყველა განსაზღვრული სერვისის კონტეინერებს  Docker Compose ფაილიდან.
    
    - ასევე სერვისებს  ბექგრაუნდში.
3. გადამოწმება**:**
    - მიმდინარე კონტეინერების ნახვა: დავრწმუნდებით, რომ `flask-backend` და `nginx-frontend` კონტეინერები გაშვებულია.
        
        ```bash
        docker ps
        ```
        
    - Frontend-ის გახსნა:
    გახსენით ბრაუზერში `http://localhost`.
    - Backend-ის ლოგების ნახვა (საჭიროების შემთხვევაში):
        
        ```bash
        docker logs flask-backend
        ```
        
4. გაშვების გაჩერება:
სერვისების გაჩერება და ყველა დაკავშირებული რესურსის წაშლა:
    
    ```bash
    docker-compose down
    ```
    

მოკლე აღწერა nginx.conf ფაილის…

- **`events {}`**: მართავს სამუშაო პროცესებს და ქსელურ კავშირებს.
- **`http {}`**: განსაზღვრავს HTTP სერვერის პარამეტრებს.
- **`listen 80;`**: სერვერი უსმენს პორტ 80-ს.
- **`location /`**: ემსახურება ფესვურ URL-ს (`index.html`) დირექტორიიდან `/usr/share/nginx/html`.
- **`location /welcome`**: ეძებს `welcome.html` ფაილს; თუ არ არსებობს, აბრუნებს 404 შეცდომას.
- `location /api/` სექცია NGINX-ში განსაზღვრავს, რომ `/api/` მისამართზე მიღებული მოთხოვნები გადამისამართდეს Flask backend სერვერზე `http://flask-backend:5000/`.
- **`proxy_pass`**: გადასცემს მოთხოვნას Flask backend-ს.
- **`proxy_set_header Host $host;`**: უზრუნველყოფს, რომ backend მიიღებს კლიენტის ჰოსტნეიმს.
- **`proxy_set_header X-Real-IP $remote_addr;`**: გადასცემს კლიენტის რეალურ IP-ს backend-

### docker-compose ფაილის აღწერა

1. **`services`**:
    - განსაზღვრავს Docker-ის სერვისებს, რომლებიც კონფიგურაციის ფარგლებში უნდა გაიშვას.
2. **`backend` სერვისი**:
    - **`build.context`**: მიუთითებს, რომ `./backend` დირექტორიაში არსებული Dockerfile უნდა გამოიყენოს.
    - **`container_name`**: ქმნის კონტეინერს სახელით `flask-backend`.
    - **`ports`**: აკავშირებს კონტეინერის შიდა პორტ 5000-ს მასპინძლის პორტ 5000-თან.
    - **`networks`**: აკავშირებს კონტეინერს `app-network` ქსელთან.
3. **`frontend` სერვისი**:
    - **`build.context`**: მიუთითებს, რომ `./frontend` დირექტორიაში არსებული Dockerfile უნდა გამოიყენოს.
    - **`container_name`**: ქმნის კონტეინერს სახელით `nginx-frontend`.
    - **`ports`**: აკავშირებს კონტეინერის შიდა პორტ 80-ს მასპინძლის პორტ 80-თან.
    - **`depends_on`**: მიუთითებს, რომ `frontend` სერვისი უნდა გაშვდეს `backend`ზე დამოკიდებულებით.
    - **`networks`**: აკავშირებს კონტეინერს `app-network` ქსელთან.
4. **`networks`**:
    - **`app-network`**: ქმნის `bridge` ტიპის ქსელს, რომელიც უზრუნველყოფს `frontend` და `backend` სერვისების ერთმანეთთან კომუნიკაციას.


------------------------------------------------------------------------------------------------------------------------------------------
ქსელის კონფიგურაცია სერვისებს შორის ხდება Docker-ის ქსელის მექანიზმის გამოყენებით, რომელიც განსაზღვრულია `docker-compose.yml` ფაილში. კონფიგურაციაში შექმნილია `app-network`, რომელიც არის bridge ტიპის ქსელი. ორივე სერვისი, ანუ `backend` და `frontend`, მიერთებულია ამ ქსელს, რაც მათ საშუალებას აძლევს ერთმანეთის Namen სახელით დაეკონტაქტონ, მაგალითად, `frontend` სერვისი უკავშირდება `backend` სერვისს სახელით `flask-backend` და პორტით `5000`. ეს იზოლირებული ქსელი უზრუნველყოფს სერვისებს შორის უსაფრთხო და მარტივ კომუნიკაციას Docker-ის ეკოსისტემაში, რაც ხელს უწყობს მორთვინასა და ოპერაციის ეფექტურობას.
